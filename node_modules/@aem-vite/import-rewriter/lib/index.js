"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  bundlesImportRewriter: () => bundlesImportRewriter
});
module.exports = __toCommonJS(src_exports);

// src/bundles.ts
var import_fs2 = require("fs");
var import_path2 = require("path");
var import_es_module_lexer = require("es-module-lexer");
var import_magic_string = __toESM(require("magic-string"));

// src/helpers.ts
var import_crypto = require("crypto");
var import_debug = __toESM(require("debug"));
var import_fs = require("fs");
var import_path = require("path");
var entryPaths = /* @__PURE__ */ new Set();
var debug = (0, import_debug.default)("aem-vite-import-rewriter");
var relativePathPattern = /([.]{1,2}\/)+/;
function getEntryPaths() {
  return entryPaths;
}
function setEntryPath(path) {
  entryPaths.add(path);
}
function isOutputChunk(assetOrChunk) {
  return typeof assetOrChunk.imports !== void 0;
}
function generateChecksum(source) {
  return (0, import_crypto.createHash)("md5").update(source, "utf8").digest("hex");
}
function getCacheKey(entryPath, keyFormat) {
  let keyFormatString = "";
  switch (keyFormat) {
    case "cloud":
      keyFormatString = "lc-%s-lc.%m";
      break;
    case "acs-classic":
      keyFormatString = "%s.%m";
      break;
    case "acs-modern":
      keyFormatString = "%m.ACSHASH%s";
      break;
  }
  const combinedContents = [...entryPaths].map((entry) => {
    const path = (0, import_path.join)(entryPath, entry);
    return (0, import_fs.existsSync)(path) ? (0, import_fs.readFileSync)(path).toString() : "";
  });
  return keyFormatString.replace("%s", generateChecksum(combinedContents.join("")));
}
function getAemClientLibPath(options, forImport = false, withChecksum = false, rollupOptions) {
  let path = options.publicPath;
  if (forImport) {
    return `${path}/${options.resourcesPath}/`;
  }
  if (withChecksum && options.caching && options.caching.enabled && rollupOptions !== void 0) {
    const entryPath = rollupOptions.dir;
    path = `${path}.${getCacheKey(entryPath, options.caching.keyFormat)}`;
    path = path.replace(".%m", options.minify === true ? ".min" : "");
  }
  return `${path}.js`;
}
function getReplacementPath(parentPath, path, options, entryAliases) {
  const isEntryPath = entryPaths.has(parentPath);
  if (isEntryPath) {
    return path.replace(new RegExp(`^${relativePathPattern.source}`), getAemClientLibPath(options, true));
  }
  return isInputAnEntryAlias(path, entryAliases) ? path.replace(
    new RegExp(`${relativePathPattern.source}${path.replace(relativePathPattern, "")}`),
    getAemClientLibPath(options)
  ) : path;
}
function isInputAnEntryAlias(input, entryAliases) {
  var _a;
  const entryAliasesExpr = new RegExp(`^[./]+(${Object.keys(entryAliases).join("|")})\\.js$`);
  return ((_a = input.match(entryAliasesExpr)) == null ? void 0 : _a[0]) ? true : false;
}

// src/bundles.ts
function bundlesImportRewriter(options) {
  const entryAliases = {};
  return {
    apply: "build",
    enforce: "post",
    name: "aem-vite:import-rewriter",
    configResolved(config) {
      const inputs = config.build.rollupOptions.input;
      if (!inputs || typeof inputs !== "object" || Array.isArray(inputs)) {
        throw new Error(
          "Missing valid input aliases which are required to map to an AEM ClientLib path, see https://www.aemvite.dev/guide/front-end/vite/#source-structure for more information."
        );
      }
      for (const [key, value] of Object.entries(inputs)) {
        if (/(ts|js)x?$/.test(value)) {
          entryAliases[key] = value;
        }
      }
      if (Object.keys(entryAliases).length > 1) {
        throw new Error(
          "Invalid number of JavaScript inputs provided. Only a single input is currently supported which is a limitation of AEM ClientLibs. It is recommended to create a second ClientLib and Vite config if you need to meet this need."
        );
      }
    },
    async renderChunk(source, chunk, rollupOptions) {
      if (rollupOptions.format !== "es") {
        return null;
      }
      if (!options.publicPath || !options.publicPath.length) {
        this.error(
          `'publicPath' doesn't appear to be defined, see https://aemvite.dev/guide/faqs/#vite-errors for more information.`
        );
      }
      if (chunk.isEntry && chunk.facadeModuleId && /(ts|js)x?$/.test(chunk.facadeModuleId)) {
        debug("setting new entry path: %s\n", chunk.fileName);
        setEntryPath(chunk.fileName);
      }
      await import_es_module_lexer.init;
      let imports = [];
      try {
        imports = (0, import_es_module_lexer.parse)(source)[0];
      } catch (e) {
        this.error(e, e.idx);
      }
      if (!imports.length) {
        return null;
      }
      let s;
      const str = () => s || (s = new import_magic_string.default(source));
      for (let index = 0; index < imports.length; index++) {
        const { e: end, d: dynamicIndex, n: importPath, s: start } = imports[index];
        if (dynamicIndex === -1 && importPath && relativePathPattern.test(importPath)) {
          const replacementPath = getReplacementPath(chunk.fileName, importPath, options, entryAliases);
          debug("render chunk (dynamic import) chunk: %s", chunk.fileName);
          debug("render chunk (dynamic import) import: %s", importPath);
          debug("render chunk (dynamic import) replacement: %s\n", replacementPath);
          str().overwrite(start, end, replacementPath);
        }
      }
      if (s) {
        return {
          code: s.toString(),
          map: rollupOptions.sourcemap !== false ? s.generateMap({ hires: true }) : null
        };
      }
      return null;
    },
    async writeBundle(rollupOptions, bundles) {
      const aemClientLibPath = getAemClientLibPath(options);
      for (const [fileName, chunk] of Object.entries(bundles)) {
        if (!isOutputChunk(chunk) || !chunk.code) {
          continue;
        }
        const source = chunk.code;
        await import_es_module_lexer.init;
        let imports = [];
        try {
          imports = (0, import_es_module_lexer.parse)(source)[0];
        } catch (e) {
          this.error(e, e.idx);
        }
        if (!imports.length) {
          continue;
        }
        let s;
        const str = () => s || (s = new import_magic_string.default(source));
        for (let index = 0; index < imports.length; index++) {
          const { e: end, d: dynamicIndex, n: importPath, s: start } = imports[index];
          if (dynamicIndex === -1 && importPath && relativePathPattern.test(importPath)) {
            const replacementPath = getReplacementPath(chunk.fileName, importPath, options, entryAliases);
            debug("write bundle (native import) chunk: %s", chunk.fileName);
            debug("write bundle (native import) import: %s\n", importPath);
            str().overwrite(start, end, replacementPath);
          }
          if (dynamicIndex > -1 && importPath) {
            debug("write bundle (dynamic import) chunk: %s", chunk.fileName);
            debug("write bundle (dynamic import) import: %s\n", importPath);
            const dynamicEnd = source.indexOf(")", end) + 1;
            const original = source.slice(dynamicIndex + 8, dynamicEnd - 2);
            debug(
              "write bundle (dynamic import) replacement:",
              getReplacementPath(chunk.fileName, importPath, options, entryAliases)
            );
            if (!original.startsWith("/")) {
              str().overwrite(start + 1, end - 1, getReplacementPath(chunk.fileName, importPath, options, entryAliases));
            }
          }
        }
        let aemImportPath = aemClientLibPath;
        let newSource = s && s.toString() || source;
        if (options.caching && options.caching.enabled) {
          aemImportPath = getAemClientLibPath(options, false, true, rollupOptions);
        }
        newSource = newSource.replace(new RegExp(aemClientLibPath, "g"), aemImportPath);
        const relativeClientLibPath = aemImportPath.substring(aemImportPath.lastIndexOf("/") + 1);
        getEntryPaths().forEach((path) => {
          newSource = newSource.replace(new RegExp(path, "g"), relativeClientLibPath);
        });
        (0, import_fs2.writeFileSync)((0, import_path2.join)(rollupOptions.dir, fileName), newSource);
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bundlesImportRewriter
});
//# sourceMappingURL=index.js.map